# $1 - main window name
# $2, $3 - width and height of the window
# $4 - optional status window name
# $5, $6 - width and height of the window
#
# $ZUILIST_NONSELECTABLE_ELEMENTS - array of indexes (1-based) that cannot be selected
# $ZUILIST_HOP_INDICES - array of indexes (1-based) jumpable with [, ]
#
# $REPLY is the output variable - contains index (1-based) or -1 when no selection
# $reply (array) is the second part of the output - use the index (REPLY) to get selected element
#
# This function outputs a list of elements that can be navigated with keyboard.
# Besides vertical navigation, it does horizontal navigation over elements of line.
# Uses curses library.

emulate -LR zsh

setopt typesetsilent extendedglob noshortloops
[[ "${ZUI[PROMPT_SUBST]}" = "1" ]] && setopt promptsubst

zmodload zsh/curses
zmodload zsh/terminfo 2>/dev/null

trap "REPLY=-2; reply=(); return" TERM INT QUIT

[[ "${ZUI[stdlib_sourced]}" != "1" ]] && source "${ZUI_REPO_DIR}/lib/stdlib.lzui"
[[ "${ZUI[syslib_sourced]}" != "1" ]] && source "${ZUI_REPO_DIR}/lib/syslib.lzui"

# Outputs a message in the bottom of the screen
# "[UNIQ]", "Text", "[Grep string]", "Generation time", "$reply[@]" from callback
-zui_list_status_msg() {
    integer indent=2 line="${ZUI[status_border]}"

    zcurses clear "$wname_status"
    zcurses move "$wname_status" $line $indent
    zcurses string "$wname_status" "$1"
    (( status_msg_strlen += ${#1} ))
}

# $1 is window name, $2 is the expected cursor state (0 invisible, 1 visible)
# Prefer module terminfo, then tput
-zui_list_cursor_visibility() {
    # If $1 = plain, then just output the
    # codes without any state management
    if [[ "$1" != "plain" ]]; then
        # Don't change already set cursor state
        [[ "$cursor_state[$1]" = "$2" ]] && return
        cursor_state[$1]="$2"
    fi

    if [[ -n "${terminfo[cvvis]}" && -n ${terminfo[cnorm]} ]]; then
        [[ "$2" = "1" ]] && { echo -En $terminfo[cvvis]; echo -En $terminfo[cnorm]; }
        [[ "$2" = "0" ]] && echo -n $terminfo[civis]
    elif type tput 2>/dev/null 1>&2; then
        [[ "$2" = "1" ]] && { tput cvvis; tput cnorm; }
        [[ "$2" = "0" ]] && tput civis
    fi 
}

# Conditional, fully robust page-to-show computation
-zui_list_compute_exact_page_if_needed() {
    # Fallback: in case of any problems compute exact page
    if [[ "${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]}" -lt "1" ||
        "${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]}" -gt "$last_element" ]]
    then
        ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]=$(( ((ZUI[CURRENT_IDX]-1)/page_height)*page_height+1 ))
    fi
}

# Compute first to show index - page is
# scrolled to center to show given index
-zui_list_compute_first_to_show_idx_center() {
    (( ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]=ZUI[CURRENT_IDX]-page_height/2 ))
    -zui_list_compute_exact_page_if_needed
}

# current_difference - how many to subtract from current
# element index, last_element_difference - how many to
# subtract from element total count. These values allow
# to provide navigation information when non-selectables
# (non-real elements) are present.
-zui_list_compute_user_vars_difference() {
    # No non-selectables -> no job to do
    if [[ "${(t)ZUILIST_NONSELECTABLE_ELEMENTS}" != *array* ]]
    then
        last_element_difference=0
        current_difference=0
    else
        last_element_difference=${#ZUILIST_NONSELECTABLE_ELEMENTS}
        current_difference=0
        local idx
        for idx in "${(n)ZUILIST_NONSELECTABLE_ELEMENTS[@]}"; do
            [[ "$idx" -le "${ZUI[CURRENT_IDX]}" ]] && current_difference+=1 || break
        done
    fi
}

# List was processed, check if variables aren't off range
-zui_list_verify_vars() {
    [[ "${ZUI[CURRENT_IDX]}" -gt "$last_element" ]] && ZUI[CURRENT_IDX]="$last_element"
    [[ "${ZUI[CURRENT_IDX]}" -eq 0 && "$last_element" -ne 0 ]] && ZUI[CURRENT_IDX]=1

    # Verify that element is just visible, if not then compute exact page
    if [[ "${ZUI[CURRENT_IDX]}" -lt "${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]}" ||
        "${ZUI[CURRENT_IDX]}" -gt "$(( ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN] + page_height - 1 ))" ]]
    then
        (( ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN] = ((ZUI[CURRENT_IDX]-1)/page_height) * page_height + 1 ))
    fi
}

# Compute the variables which are shown to the user
-zui_list_setup_user_vars() {
    if [[ "$1" = "1" ]]; then
        # Basic values when there are no non-selectables
        ZUILIST_USER_CURRENT_IDX="${ZUI[CURRENT_IDX]}"
        ZUILIST_USER_LAST_ELEMENT="$last_element"
    else
        -zui_list_compute_user_vars_difference
        ZUILIST_USER_CURRENT_IDX=$(( ZUI[CURRENT_IDX] - current_difference ))
        ZUILIST_USER_LAST_ELEMENT=$(( last_element - last_element_difference ))
    fi
}

# Functionality inherited from n-list: ability to colorify
# selected keywords (via ZUILIST_COLORING_PATTERN). Here
# it uses color mark (default: \6) instead of direct usage
# of ANSI color codes. \6 is cyan by default (ZUI[CYAN]).
#
-zui_list_colorify_disp_list() {
    local col=${ZUI[CYAN]} close=${ZUI[COLOR_END]}
    [[ -n "$ZUILIST_COLORING_COLOR" ]] && col="$ZUILIST_COLORING_COLOR"
    [[ -n "$ZUILIST_COLORING_END_COLOR" ]] && close="$ZUILIST_COLORING_END_COLOR"

    if [[ "$ZUILIST_COLORING_MATCH_MULTIPLE" -eq 1 ]]; then
        disp_list=( "${(@)disp_list//(#mi)$~ZUILIST_COLORING_PATTERN/$col${MATCH}$close}" )
    else
        disp_list=( "${(@)disp_list/(#mi)$~ZUILIST_COLORING_PATTERN/$col${MATCH}$close}" )
    fi
}

# Changes color marks (default: \3, \4, \5, \6, \7) into ANSI
# color codes (default: green, yellow, magenta, cyan, red).
# Operates on disp_list array.
-zui_list_translate_color_marks_in_disp_list() {
    # [all] [fg] [bg]
    disp_list=( "${disp_list[@]//(#b)([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031'])([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\017']|)([$'\020'-$'\030']|)([^${ZUI[COLOR_END]}]#)${ZUI[COLOR_END]}/${colormap[${match[1]}]}${colormap[${match[2]}]}${colormap[${match[3]}]}$match[4]$RESET}" )
}

# Changes color marks (default: \3, \4, \5, \6, \7) into ANSI
# color codes (default: green, yellow, magenta, cyan, red).
#
# $1 - buffer to operate on
# $REPLY - modified buffer
-zui_list_translate_color_marks() {
    local buf="$1"
    # [all] [fg] [bg]
    buf="${buf//(#b)([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031'])([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\017']|)([$'\020'-$'\030']|)([^${ZUI[COLOR_END]}]#)${ZUI[COLOR_END]}/${colormap[${match[1]}]}${colormap[${match[2]}]}${colormap[${match[3]}]}$match[4]$RESET}"

    # Mark 1
    buf="${buf//(#b)${ZUI[MARK]}([^${ZUI[MARK_E]}]#)${ZUI[MARK_E]}/$MARK_CODES$match[1]$MARK_END_CODES}"
    # Mark 2 (alternative for segments with background color)
    buf="${buf//(#b)${ZUI[MARK2]}([^${ZUI[MARK_E]}]#)${ZUI[MARK_E]}/$MARK2_CODES$match[1]$MARK2_END_CODES}"

    REPLY="$buf"
}

# Replaces existing color marks to given color mark,
# or adds (wrapps with) given color mark. Used to
# highlight text.
#
# $1 - buffer to operate on
# $2 - target color mark
# $REPLY - modified buffer
-zui_list_replace_color_marks_with() {
    local buf="$1" target_mark="$2"
    # [all] [fg] [bg]
    buf=${buf//[$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031']([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\017']|)([$'\020'-$'\030']|)/$target_mark}

    # No existing replaced marks – then just add the mark
    if [[ "${buf/$target_mark/}" = "$buf" ]]; then
        buf="${target_mark}${buf}${ZUI[COLOR_END]}"
    fi

    REPLY="$buf"
}

-zui_list_mark_current_segment_in_current_element() {
        # Check if current element is in ZUILIST_NONSELECTABLE_ELEMENTS
        # If yes, don't mark current segment. Highlight anyway when
        # searching.
        [[ -z "$ZUILIST_SEARCH_BUFFER" && "$ZUILIST_IS_UNIQ_MODE" != "1" && -n "${ZUILIST_NONSELECTABLE_ELEMENTS[(r)${ZUI[CURRENT_IDX]}]}" ]] && return

        # There will be no colorifying for current element
        integer current_page_idx=$(( ZUI[CURRENT_IDX] - ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN] + 1 ))
        local element="${__list[${ZUI[CURRENT_IDX]}]}"

        local output=""

        [[ "$ZUILIST_CURRENT_SEGMENT" -lt 1 ]] && ZUILIST_CURRENT_SEGMENT=1
        [[ "$ZUILIST_CURRENT_SEGMENT" -gt "$nseg" ]] && ZUILIST_CURRENT_SEGMENT="$nseg"
        integer active_segment="$ZUILIST_CURRENT_SEGMENT"

        # Lets find interesting segment and mark it with \7...\31
        zui-process-buffer "$element"
        integer size="${#ZUI_PB_WORDS}" i
        local buf=""
        for (( i=1; i<=size; i++ )); do
            if [[ "$i" -eq "$active_segment" ]]; then
                ZUI_PB_WORDS[i]=${ZUI_PB_WORDS[i]//$'\n'/\\n}
                # Mark segment if marking always or non-hyperlink lines, or if the line contains any hyperlinks
                if [[ "${ZUI[text_mode]}" = (all|nohyp) ]] || -zui_stdlib_has_any_hyperlinks "$element"; then
                    # No background color?
                    if [[ "${ZUI_PB_WORDS[i]}" != *[$'\020'-$'\030']* && -z "${ZUI[current_tfield]}" ]]; then
                        -zui_list_replace_color_marks_with "${ZUI_PB_WORDS[i]}" "${ZUI[MARK]}"
                    else
                        -zui_list_replace_color_marks_with "${ZUI_PB_WORDS[i]}" "${ZUI[MARK2]}"
                    fi
                    ZUI_PB_WORDS[i]="$REPLY"
                fi
            fi
            buf+="$ZUI_PB_SPACES[i]$ZUI_PB_WORDS[i]"
        done
        buf+="$ZUI_PB_SPACES[i]"

        # Remove hyperlinks
        buf="${buf//(#b)$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\02']#$'\02'([^$'\02']#)$'\02'/${(Q)match[1]}}"
        #                      id                data1             data2             data3              width               sidx                text                
        buf="${buf//(#b)$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'([^$'\032']#)$'\032'([^$'\032']#)$'\032'([^$'\02']#)$'\02'/${(r:${(P)${(Q)match[1]}}-1::_:)${(P)${(Q)match[3]}}[${(P)${(Q)match[2]}},-1]}${${(P)${(Q)match[3]}}[$(( ${(P)#${(Q)match[3]}} - ${(P)${(Q)match[2]}} + 1 == ${(P)${(Q)match[1]}} ? ${(P)${(Q)match[1]}} + ${(P)${(Q)match[2]}} - 1 : 10000 ))]}${tfield_end_map[$(( ${(P)#${(Q)match[3]}} - ${(P)${(Q)match[2]}} + 1 > ${(P)${(Q)match[1]}} ? 1 : ( ${(P)#${(Q)match[3]}} - ${(P)${(Q)match[2]}} + 1 == ${(P)${(Q)match[1]}} ? 0 : 2) ))]}}"
        #                      id                data1             data2             data3              width               idx                 options text        
        buf="${buf//(#b)$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'([^$'\034']#)$'\034'([^$'\034']#)$'\034'([^$'\02']#)$'\02'/${(r:${(P)${(Q)match[1]}}:: :)${(s:;:)${(P)${(Q)match[3]}}}[${(P)${(Q)match[2]}}]}}"

        -zui_list_translate_color_marks "$buf"
        disp_list2[current_page_idx]="$REPLY"
}

-zui_list_compute_mark_codes() {
    local __actmark="$1" __altmark="$2" __out="${3:-MARK_CODES}" __out2="${4:-MARK_END_CODES}" __aout="$5"
    local __active_text

    # Check if terminal supports __underline
    # Linux has ncv 18, screen* has ncv 3 - __underline won't work properly
    (( ${+terminfo} )) && (( ${terminfo[ncv]:-0} & 2 )) && __actmark="$__altmark"
    # FreeBSD uses TERM=xterm for newcons but doesn't actually support __underline
    [[ "$TERM" = "xterm" && -z "$DISPLAY" && "${(L)OSTYPE}" = *bsd* ]] && __actmark="$__altmark"

    local __color="${__actmark%%[[:space:]]*}"
    local __color2="${${__actmark#*[[:space:]]}%%[[:space:]]*}"
    local __bold="${__actmark/*bold*/bold}"
    local __reverse="${__actmark/*(reverse|inverse)*/reverse}"
    local __blink="${__actmark/*blink*/blink}"
    local __underline="${__actmark/*underline*/underline}"
    local __linerev="${__actmark/*linerev*/linerev}"
    local __lineund="${__actmark/*lineund*/lineund}"
    local -A __colormap
    __colormap=( reset 0 black 30 red 31 green 32 yellow 33 blue 34 magenta 35 cyan 36 white 37 default 39
                       BLACK 30 RED 41 GREEN 42 YELLOW 43 BLUE 44 MAGENTA 45 CYAN 46 WHITE 47 DEFAULT 49 )
    local -aU __opening __closing
    [[ -n "${__colormap[$__color]}" ]] && { __opening+=( ${__colormap[$__color]} ); __closing+=( 0 ); }
    [[ -n "${__colormap[$__color2]}" ]] && { __opening+=( ${__colormap[$__color2]} ); __closing+=( 0 ); }
    [[ $__linerev = linerev ]] && { __active_text="reverse"; __reverse=""; }
    [[ $__lineund = lineund ]] && { __active_text="underline"; __underline=""; }
    [[ $__bold == bold ]] && { __opening+=( 1 ); __closing+=( 21 ); }
    [[ $__reverse == reverse ]] && { __opening+=( 7 ); __closing+=( 27 ); }
    [[ $__blink == blink ]] && { __opening+=( 5 ); __closing+=( 25 ); }
    [[ $__underline == underline ]] && { __opening+=( 4 ); __closing+=( 24 ); }

    local __a __opcodes __clcodes
    for __a in "${__opening[@]}"; do
        __opcodes+=$'\e'"[${__a}m"
    done
    for __a in "${__closing[@]}"; do
        __clcodes+=$'\e'"[${__a}m"
    done

    : ${(P)__out::=$__opcodes}
    : ${(P)__out2::=$__clcodes}
    [[ -n "$__aout" ]] && : ${(P)__aout::=$__active_text}
}

# Argument is "1" or "2", to select first
# or second marks for the recomputation
-zui_list_recompute_mark() {
    if [[ "$1" = "1" ]]; then
        -zui_list_compute_mark_codes "${ZUI[mark]}" "${ZUI[altmark]}" MARK_CODES MARK_END_CODES active_text
    else
        -zui_list_compute_mark_codes "${ZUI[mark2]}" "${ZUI[altmark2]}" MARK2_CODES MARK2_END_CODES
    fi
}

# Mainly for `zcurses bg`, but has some theme-related scraps
-zui_list_recompute_bg() {
    backuptheme="${ZUI[colorpair]}/${ZUI[bold]}"
    stbackuptheme="${ZUI[status_colorpair]}/${ZUI[status_bold]}"

    zcurses bg "$wname_main" "${ZUI[colorpair]}"
    zcurses bg "$wname_status" "${ZUI[status_colorpair]}"
}

-zui_list_handle_resize() {
    if -zui_wrapper_recreate_windows "$1" main_height main_width status_height status_width; then
        page_height=main_height-2
        page_width=main_width-2
        -zui_list_recompute_bg
        [[ -n "$wname_status" ]] && zcurses clear "$wname_status"
        ZUILIST_REGENERATE_LIST=2
    fi
}

#
# Main code
#

if [[ "$#" -lt 1 ]]; then
    echo "Usage: zui-list element_1 ..."
    return 1
fi

typeset -g REPLY
REPLY="-1"
typeset -ga reply
reply=()

local wname_main="$1"
integer main_height="$2"
integer main_width="$3"
local wname_status="$4"
integer status_height="$5"
integer status_width="$6"
integer page_height=main_height-2
integer page_width=main_width-2
local header="$7"

shift 7

typeset -a __list disp_list disp_list2
integer last_element=$#
local action
local final_key tmp
integer selection
integer last_element_difference=0
integer current_difference=0
local prev_search_buffer=""
integer prev_uniq_mode=0
integer prev_start_idx=-1
local MBEGIN MEND MATCH
local -a mbegin mend match
local -a segments
integer nseg

local -A "cursor_state"
cursor_state=( "main" 1 "status" 1 "field" 0 )

local -A tfield_end_map
tfield_end_map=( 0 "" 1 ">" 2 "_" )

# Escape codes for colors
local RESET=$'\e[0m' BLACK=$'\e[30m' RED=$'\e[31m' GREEN=$'\e[32m' YELLOW=$'\e[33m'
local BLUE=$'\e[34m' MAGENTA=$'\e[35m' CYAN=$'\e[36m' WHITE=$'\e[37m' DEFAULT=$'\e[39m'

# Background
local BG_BLACK=$'\e[40m' BG_RED=$'\e[41m' BG_GREEN=$'\e[42m' BG_YELLOW=$'\e[43m'
local BG_BLUE=$'\e[44m' BG_MAGENTA=$'\e[45m' BG_CYAN=$'\e[46m' BG_WHITE=$'\e[47m' BG_DEFAULT=$'\e[49m'

# Bold
local BOLD=$'\e[1m'

local -A colormap
colormap=(
    ""                ""

    $ZUI[BLACK]       $BLACK
    $ZUI[RED]         $RED
    $ZUI[GREEN]       $GREEN
    $ZUI[YELLOW]      $YELLOW
    $ZUI[BLUE]        $BLUE
    $ZUI[MAGENTA]     $MAGENTA
    $ZUI[CYAN]        $CYAN
    $ZUI[WHITE]       $WHITE
    $ZUI[DEFAULT]     $DEFAULT

    $ZUI[BG_BLACK]    $BG_BLACK
    $ZUI[BG_RED]      $BG_RED
    $ZUI[BG_GREEN]    $BG_GREEN
    $ZUI[BG_YELLOW]   $BG_YELLOW
    $ZUI[BG_BLUE]     $BG_BLUE
    $ZUI[BG_MAGENTA]  $BG_MAGENTA
    $ZUI[BG_CYAN]     $BG_CYAN
    $ZUI[BG_WHITE]    $BG_WHITE
    $ZUI[BG_DEFAULT]  $BG_DEFAULT

    $ZUI[BOLD]        $BOLD
)

#
# Load configuration – per application if ZUI[app] is set
#

local backuptheme stbackuptheme
-zui_stdlib_load_config s:colorpair "white/black" 2 'ZUI[colorpair]'
-zui_stdlib_load_config b:border 0 2 'ZUI[border]'
-zui_stdlib_load_config s:border_cp "yellow/black" 2 'ZUI[border_cp]'
-zui_stdlib_load_config b:bold 0 2 'ZUI[bold]'

-zui_stdlib_load_config s:status_colorpair "white/black" 2 'ZUI[status_colorpair]'
-zui_stdlib_load_config b:status_border 0 2 'ZUI[status_border]'
-zui_stdlib_load_config s:status_border_cp "green/black" 2 'ZUI[status_border_cp]'
-zui_stdlib_load_config b:status_bold 0 2 'ZUI[status_bold]'

-zui_stdlib_load_config s:mark "red reverse lineund" 2 'ZUI[mark]'
-zui_stdlib_load_config s:altmark "red reverse" 2 'ZUI[altmark]'
-zui_stdlib_load_config s:mark2 "yellow reverse lineund" 2 'ZUI[mark2]'
-zui_stdlib_load_config s:altmark2 "yellow reverse" 2 'ZUI[altmark2]'
-zui_stdlib_load_config s:select_mode "no-restart" 2 'ZUI[select_mode]'
-zui_stdlib_load_config s:text_mode "all" 2 'ZUI[text_mode]'
-zui_stdlib_load_config b:text_select 1 2 'ZUI[text_select]'
-zui_stdlib_load_config b:status_pointer 1 2 'ZUI[status_pointer]'
-zui_stdlib_load_config s:log_append "above" 2 'ZUI[log_append]'
-zui_stdlib_load_config b:log_index 1 2 'ZUI[log_index]'
-zui_stdlib_load_config s:log_size "32" 2 'ZUI[log_size]'
-zui_stdlib_load_config s:log_time_format "[%H:%M] " 2 'ZUI[log_time_format]'
-zui_stdlib_load_config s:log_colors "white cyan yellow green cyan red magenta yellow blue" 2 'ZUI[log_colors]'
local -a log_colors
log_colors=( "${=ZUI[log_colors]}" )

# Process configuration
local MARK_CODES MARK_END_CODES MARK2_CODES MARK2_END_CODES active_text

-zui_list_recompute_mark 1
-zui_list_recompute_mark 2
-zui_list_recompute_bg

# Ability to remember the list between calls
if [[ -z "$ZUILIST_REMEMBER_STATE" || "$ZUILIST_REMEMBER_STATE" = 0 || "$ZUILIST_REMEMBER_STATE" = 2 ]]; then
    ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]=1
    ZUI[CURRENT_IDX]=1
    ZUILIST_IS_SEARCH_MODE=0
    ZUILIST_SEARCH_BUFFER=""
    ZUILIST_TEXT_OFFSET=0
    ZUILIST_IS_UNIQ_MODE=0
    ZUILIST_CURRENT_SEGMENT=1 # This variable is responsible for horizontal indexing
    ZUILIST_ACTIVE_SEGMENTS=()
    typeset -ga +U ZUILIST_NONSELECTABLE_ELEMENTS
    typeset -ga +U ZUILIST_HOP_INDICES

    # Zero - because it isn't known, unless we
    # confirm that first element is selectable
    ZUILIST_USER_CURRENT_IDX=0
    [[ -z "${ZUILIST_NONSELECTABLE_ELEMENTS[(r)1]}" ]] && ZUILIST_USER_CURRENT_IDX=1
    ZUILIST_USER_LAST_ELEMENT=$(( last_element - $#ZUILIST_NONSELECTABLE_ELEMENTS ))

    # 2 is init once, then remember
    [[ "$ZUILIST_REMEMBER_STATE" -eq 2 ]] && ZUILIST_REMEMBER_STATE=1
else
    # Recompute ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN] in case it
    # was manually altered outside the list. Together with
    # this verify variables.
    -zui_list_verify_vars

    # This retains previous parameters, adds unique flag
    typeset -ga +U ZUILIST_NONSELECTABLE_ELEMENTS
    typeset -ga +U ZUILIST_HOP_INDICES
fi

if [[ "$ZUILIST_START_IN_SEARCH_MODE" -eq 1 ]]; then
    ZUILIST_START_IN_SEARCH_MODE=0
    ZUILIST_IS_SEARCH_MODE=1
fi

if [[ -n "$ZUILIST_SET_SEARCH_TO" ]]; then
    ZUILIST_SEARCH_BUFFER="$ZUILIST_SET_SEARCH_TO"
    ZUILIST_SET_SEARCH_TO=""
fi

if [[ "$ZUILIST_START_IN_UNIQ_MODE" -eq 1 ]]; then
    ZUILIST_START_IN_UNIQ_MODE=0
    ZUILIST_IS_UNIQ_MODE=1
fi

#
# Listening for input
#

local key keypad

# Clear input buffer
zcurses timeout "$wname_main" 0
zcurses input "$wname_main" key keypad
zcurses timeout "$wname_main" -1
key=""
keypad=""

# Initial list. $@ later still serves as verbatim input.
# This loop makes script faster on some Zsh's (e.g. 5.0.8)
repeat 1; do
    __list=( "$@" )
done

last_element="${#__list}"

while (( 1 )); do
    # Handle resize, once every 5 seconds
    -zui_list_handle_resize 0

    # Do searching?
    if [[ -n "$ZUILIST_SEARCH_BUFFER" ]]; then
        # Compute new list?
        if [[ "$ZUILIST_SEARCH_BUFFER" != "$prev_search_buffer" || "$ZUILIST_IS_UNIQ_MODE" -ne "$prev_uniq_mode" || "$ZUILIST_REGENERATE_LIST" = "1" ]]
        then
            prev_search_buffer="$ZUILIST_SEARCH_BUFFER"
            prev_uniq_mode="$ZUILIST_IS_UNIQ_MODE"
            # regenerating list -> regenerating disp_list
            ZUILIST_REGENERATE_LIST="2"

            # Take all elements, including duplicates and non-selectables
            typeset +U __list
            repeat 1; do
                __list=( "$@" )
            done

            # Remove non-selectable elements
            [[ "$#ZUILIST_NONSELECTABLE_ELEMENTS" -gt 0 ]] && for i in "${(nO)ZUILIST_NONSELECTABLE_ELEMENTS[@]}"; do
                __list[$i]=()
            done

            # Remove duplicates
            [[ "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]] && typeset -U __list

            last_element="${#__list}"

            # Next do the filtering
            local search_buffer="${ZUILIST_SEARCH_BUFFER%% ##}"
            search_buffer="${search_buffer## ##}"
            search_buffer="${search_buffer//(#m)[][*?|#~^()><\\]/\\$MATCH}"
            local search_pattern=""
            local colsearch_pattern=""
            if [[ -n "$search_buffer" ]]; then
                # The base bit of this pattern is ((#s)[^$'\01']#THEWORD*|*$'\02'[^$'\01']#THEWORD*) - the word
                # occuring not inside hyper link
                # Pattern will be ((#s)[^$'\01']#FOO*|*$'\02'[^$'\01']#FOO*)~^((#s)[^$'\01']#BAR*|*$'\02'[^$'\01']#BAR*...)
                # ~^ means: "not those that have not this"
                search_pattern=${search_buffer//(#b)([^ ]##)/((#s)[^$'\01'$'\032'$'\034']#${match[1]}*|*[$'\02'][^$'\01'$'\032'$'\034']#${match[1]}*)~^}
                search_pattern="${search_pattern// ##/}"
                search_pattern="${search_pattern%\~\^}"
                # Pattern will be (foo|bar)
                colsearch_pattern="${search_buffer// ##/|}"

                # The repeat will make the matching work on a fresh heap arena
                repeat 1; do
                    __list=( "${(@M)__list:#(#i)$~search_pattern}" )
                done

                last_element="${#__list}"
            fi

            # Called after processing list
            -zui_list_verify_vars
        fi

        -zui_list_setup_user_vars 1
        segments=( "${(z@)__list[${ZUI[CURRENT_IDX]}]}" )
        nseg="$#segments"

        integer end_idx=$(( ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN] + page_height - 1 ))
        [[ "$end_idx" -gt "$last_element" ]] && end_idx=last_element

        if [[ "$ZUILIST_REGENERATE_LIST" = "2" || "$prev_start_idx" -ne "${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]}" ]]; then
            ZUILIST_REGENERATE_LIST="0"
            prev_start_idx="${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]}"
            disp_list=( "${(@)__list[${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]},end_idx]}" )

            # Remove hyperlinks before colorifying
            disp_list=( "${disp_list[@]//(#b)$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\02']#$'\02'([^$'\02']#)$'\02'/${(Q)match[1]}}" )
            #                                       id                data1             data2             data3              width               sidx                text        
            disp_list=( "${disp_list[@]//(#b)$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'([^$'\032']#)$'\032'([^$'\032']#)$'\032'([^$'\02']#)$'\02'/${(r:${(P)${(Q)match[1]}}-1::_:)${(P)${(Q)match[3]}}[${(P)${(Q)match[2]}},-1]}${${(P)${(Q)match[3]}}[$(( ${(P)#${(Q)match[3]}} - ${(P)${(Q)match[2]}} + 1 == ${(P)${(Q)match[1]}} ? ${(P)${(Q)match[1]}} + ${(P)${(Q)match[2]}} - 1 : 10000 ))]}${tfield_end_map[$(( ${(P)#${(Q)match[3]}} - ${(P)${(Q)match[2]}} + 1 > ${(P)${(Q)match[1]}} ? 1 : ( ${(P)#${(Q)match[3]}} - ${(P)${(Q)match[2]}} + 1 == ${(P)${(Q)match[1]}} ? 0 : 2) ))]}}" )
            #                                       id                data1             data2             data3              width               idx                 options text        
            disp_list=( "${disp_list[@]//(#b)$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'([^$'\034']#)$'\034'([^$'\034']#)$'\034'([^$'\02']#)$'\02'/${(r:${(P)${(Q)match[1]}}:: :)${(s:;:)${(P)${(Q)match[3]}}}[${(P)${(Q)match[2]}}]}}" )

            if [[ -n "$colsearch_pattern" ]]; then
                local col="${ZUI[BG_MAGENTA]}" close="${ZUI[COLOR_END]}"
                # The repeat will make the matching work on a fresh heap arena
                repeat 1; do
                    disp_list=( ${(@)disp_list//(#mi)($~colsearch_pattern)/$col${MATCH}$close} )
                    # [Mark][Text][$col-Mark][Text2][Close]... -> [Mark][Text][Close][$col-Mark][Text2][Close][Mark]
                    # I.e. provide [Close] before [$col-Mark] and [Mark] after $col's [Close]
                    # Here is the ancient common *_E obstacle - we can easily use only single [Close] in the substitution
                    while (( 1 )); do
                        # [all] [fg] [bg], matches more combinations but solves and is fast
                        mbegin=()
                        disp_list=( ${(@)disp_list//(#b)([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031']([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\017']|)([$'\020'-$'\030']|))([^$close]#)$col([^$close]#)$close/$match[1]$match[4]$close$col$match[5]$close$match[1]} )
                        [[ -z "${mbegin[1]}" ]] && break
                    done
                done
            fi
            # We translate color marks into color codes. list still contains marks,
            # and -zui_list_mark_current_segment_in_current_element will be able
            # to restore current element into marks, to switch colors of active
            # segment
            -zui_list_translate_color_marks_in_disp_list
        fi

        # We need second disp_list to be able to traverse with mark
        # freely without regenerating disp_list
        disp_list2=( "${(@)disp_list}" )

        [[ "$#disp_list2" -gt 0 ]] && -zui_list_mark_current_segment_in_current_element

        # Output colored list
        zui-list-draw "$(( ZUI[CURRENT_IDX] - ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN] + 1 ))" \
            "$page_height" "$page_width" 1 2 "$ZUILIST_TEXT_OFFSET" "$wname_main" "$active_text" \
            "$disp_list2[@]"
    else
        # There is no search, but there was in previous loop
        # OR
        # Uniq mode was entered or left out
        # -> compute new list
        if [[ -n "$prev_search_buffer" || "$ZUILIST_IS_UNIQ_MODE" -ne "$prev_uniq_mode" || "$ZUILIST_REGENERATE_LIST" = "1" ]]
        then
            # regenerating list -> regenerating disp_list
            ZUILIST_REGENERATE_LIST="2"
            prev_search_buffer=""
            prev_uniq_mode="$ZUILIST_IS_UNIQ_MODE"

            # Take all elements, including duplicates and non-selectables
            typeset +U __list
            repeat 1; do
                __list=( "$@" )
            done

            # Remove non-selectable elements only when in uniq mode
            [[ "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]] && [[ "$#ZUILIST_NONSELECTABLE_ELEMENTS" -gt 0 ]] &&
            for i in "${(nO)ZUILIST_NONSELECTABLE_ELEMENTS[@]}"; do
                __list[$i]=()
            done

            # Remove duplicates when in uniq mode
            [[ "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]] && typeset -U __list

            last_element="${#__list}"
            # Called after processing list
            -zui_list_verify_vars
        fi

        # If the argument is 1, then: don't bother with non-selectables
        -zui_list_setup_user_vars "$ZUILIST_IS_UNIQ_MODE"
        segments=( "${(z@)__list[${ZUI[CURRENT_IDX]}]}" )
        nseg="$#segments"

        integer end_idx=$(( ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN] + page_height - 1 ))
        [[ "$end_idx" -gt "$last_element" ]] && end_idx=last_element

        if [[ "$ZUILIST_REGENERATE_LIST" = "2" || "$prev_start_idx" -ne "${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]}"  ]]; then
            ZUILIST_REGENERATE_LIST="0"
            prev_start_idx="${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]}"
            disp_list=( "${(@)__list[${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]},end_idx]}" )

            # Remove hyperlinks
            disp_list=( "${disp_list[@]//(#b)$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\02']#$'\02'([^$'\02']#)$'\02'/${(Q)match[1]}}" )
            #                                       id                data1             data2             data3              width               sidx                text        
            disp_list=( "${disp_list[@]//(#b)$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'([^$'\032']#)$'\032'([^$'\032']#)$'\032'([^$'\02']#)$'\02'/${(r:${(P)${(Q)match[1]}}-1::_:)${(P)${(Q)match[3]}}[${(P)${(Q)match[2]}},-1]}${${(P)${(Q)match[3]}}[$(( ${(P)#${(Q)match[3]}} - ${(P)${(Q)match[2]}} + 1 == ${(P)${(Q)match[1]}} ? ${(P)${(Q)match[1]}} + ${(P)${(Q)match[2]}} - 1 : 10000 ))]}${tfield_end_map[$(( ${(P)#${(Q)match[3]}} - ${(P)${(Q)match[2]}} + 1 > ${(P)${(Q)match[1]}} ? 1 : ( ${(P)#${(Q)match[3]}} - ${(P)${(Q)match[2]}} + 1 == ${(P)${(Q)match[1]}} ? 0 : 2) ))]}}" )
            #                                       id                data1             data2             data3              width               idx                 options text        
            disp_list=( "${disp_list[@]//(#b)$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'([^$'\034']#)$'\034'([^$'\034']#)$'\034'([^$'\02']#)$'\02'/${(r:${(P)${(Q)match[1]}}:: :)${(s:;:)${(P)${(Q)match[3]}}}[${(P)${(Q)match[2]}}]}}" )

            # We translate color marks into color codes. list still contains marks,
            # and -zui_list_mark_current_segment_in_current_element will be able
            # to restore current element into marks, to switch colors of active
            # segment
            -zui_list_translate_color_marks_in_disp_list

            [[ -n "$ZUILIST_COLORING_PATTERN" ]] && -zui_list_colorify_disp_list
        fi

        # We need second disp_list to be able to traverse with mark
        # freely without regenerating disp_list
        disp_list2=( "${(@)disp_list}" )

        [[ "$#disp_list2" -gt 0 ]] && -zui_list_mark_current_segment_in_current_element

        # Output the list
        zui-list-draw "$(( ZUI[CURRENT_IDX] - ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN] + 1 ))" \
            "$page_height" "$page_width" 1 2 "$ZUILIST_TEXT_OFFSET" "$wname_main" "$active_text" \
            "$disp_list2[@]"
    fi

    [[ "${ZUI[bold]}" = "1" ]] && local wrk_bold="+bold" || local wrk_bold="-bold"

    # The check for "white/black" means: mark header
    # only when default color isn't special
    zcurses attr "$wname_main" "$wrk_bold" "${ZUI[border_cp]}"

    [[ "${ZUI[border]}" = "1" ]] && zcurses border "$wname_main"
    zcurses move "$wname_main" 0 2
    zcurses string "$wname_main" "$header"

    zcurses attr "$wname_main" "$wrk_bold" "${ZUI[colorpair]}"

    -zui_list_cursor_visibility "main" "0"
    zcurses refresh "$wname_main"

    # Status window is optional (1/2)
    [[ -n "$wname_status" ]] && {
        [[ "${ZUI[status_bold]}" = "1" ]] && local wrk_stbold="+bold" || local wrk_stbold="-bold"

        zcurses attr "$wname_status" "$wrk_stbold" "${ZUI[status_colorpair]}"

        reply=( )
        local selectable=1 tpe=-1 status_msg_strlen=0
        [[ -n "${ZUILIST_NONSELECTABLE_ELEMENTS[(r)${ZUI[CURRENT_IDX]}]}" ]] && selectable=0
        (( $ZUILIST_IS_UNIQ_MODE + ${${ZUILIST_SEARCH_BUFFER:+1}:-0} )) && selectable=1
        if (( selectable == 0 )) || ! -zui_stdlib_decode "${segments[ZUILIST_CURRENT_SEGMENT]}"; then
            reply=( "$selectable" "$ZUILIST_IS_UNIQ_MODE" "${${ZUILIST_SEARCH_BUFFER:+1}:-0}" "${__list[${ZUI[CURRENT_IDX]}]}" "${segments[ZUILIST_CURRENT_SEGMENT]}" )
            REPLY="0"
        fi
        (( ${+functions[-zui-standard-status-callback]} )) && {
            -zui-standard-status-callback "$REPLY" "${reply[@]}"
            tpe=$?
        }
        ZUI[pressed_now]=""
        ZUI[pure_text_selected]=""
        ZUI[line_selected]=""

        (( tpe > 0 )) && -zui_stdlib_add_message "$tpe" "${EPOCHSECONDS:-0}" "${reply[@]}"

        if [[ "$ZUILIST_IS_SEARCH_MODE" = "0" ]]; then
            -zui-log "$wname_status" "$status_height" "$status_width" "${ZUI[status_border]}" "${ZUI[status_colorpair]}" \
                    "$ZUILIST_GREP_STRING" "$ZUILIST_IS_UNIQ_MODE" "$ZUILIST_IS_SEARCH_MODE" \
                    "${ZUI[GENERATION_TIME]}" "$selectable" "${${ZUILIST_SEARCH_BUFFER:+1}:-0}" \
                    "$ZUILIST_USER_CURRENT_IDX" "$ZUILIST_USER_LAST_ELEMENT"

            ZUI[GENERATION_TIME]=""
        else
            -zui_list_status_msg "Filtering with: ${ZUILIST_SEARCH_BUFFER// /+}"
        fi

        [[ "${ZUI[status_border]}" = "1" ]] && {
            zcurses attr "$wname_status" "$wrk_stbold" "${ZUI[status_border_cp]}"
            zcurses border "$wname_status"
            zcurses attr "$wname_status" "$wrk_stbold" "${ZUI[status_colorpair]}"
        }

        # status_msg_strlen is being set in -zui_list_status_msg()
        zcurses move "$wname_status" "${ZUI[status_border]}" $(( status_msg_strlen + 2 ))
        [[ "$ZUILIST_IS_SEARCH_MODE" -ne 1 ]] && -zui_list_cursor_visibility "status" "0" || -zui_list_cursor_visibility "status" "1"
        zcurses refresh "$wname_status" 
    }

    if [[ -n "${ZUI[current_tfield]}" ]]; then
        zcurses move "$wname_main" "${ZUI[cursor_y]}" $(( ZUI[cursor_x] + 2 ))
        -zui_list_cursor_visibility "field" 1
    else
        -zui_list_cursor_visibility "field" 0
    fi

    # Draw only?
    [[ "$ZUILIST_DRAW_ONLY" = "1" ]] && return

    # Wait for input
    key="" keypad="" final_key=""
    zcurses input "$wname_main" key keypad

    # Get the special (i.e. "keypad") key or regular key
    if [[ -n "$key" ]]; then
        final_key="$key"
    elif [[ -n "$keypad" ]]; then
        final_key="$keypad"
    elif [[ -n "$wname_status" ]]; then
        -zui_stdlib_add_message 1 "${EPOCHSECONDS:-0}" "" "" "Warning: " "Improper input detected"
    fi

    integer track_cur_idx="${ZUI[CURRENT_IDX]}"
    zui-list-input "${ZUI[CURRENT_IDX]}" "$ZUILIST_CURRENT_SEGMENT" "${ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]}" \
                    "$page_height" "$page_width" "$last_element" "$nseg" "$ZUILIST_TEXT_OFFSET" \
                    "$final_key" "$ZUILIST_IS_SEARCH_MODE" "$ZUILIST_SEARCH_BUFFER" \
                    "$ZUILIST_IS_UNIQ_MODE" "$ZUILIST_DISABLE_SEARCH" "__list"

    selection="$reply[1]"
    action="$reply[2]"
    ZUI[CURRENT_IDX]="$reply[3]"
    ZUILIST_CURRENT_SEGMENT="$reply[4]"
    ZUI[FROM_WHAT_IDX_LIST_IS_SHOWN]="$reply[5]"
    ZUILIST_TEXT_OFFSET="$reply[6]"
    ZUILIST_IS_SEARCH_MODE="$reply[7]"
    ZUILIST_SEARCH_BUFFER="$reply[8]"
    ZUILIST_IS_UNIQ_MODE="$reply[9]"

    #
    # Remember selected segment at each line?
    # (functionality)
    #

    if [[ "$ZUILIST_TRACK_SEGMENTS" = "1" ]]; then
        # Remember segment change (element change and
        # segment change cannot occur at the same time)
        ZUILIST_ACTIVE_SEGMENTS[$track_cur_idx]="$ZUILIST_CURRENT_SEGMENT"

        if [[ "$track_cur_idx" != "${ZUI[CURRENT_IDX]}" ]]; then
            # Restore segment or set to 1
            if (( ${+ZUILIST_ACTIVE_SEGMENTS[${ZUI[CURRENT_IDX]}]} )); then
                ZUILIST_CURRENT_SEGMENT="${ZUILIST_ACTIVE_SEGMENTS[${ZUI[CURRENT_IDX]}]}"
            else
                ZUILIST_CURRENT_SEGMENT=1
            fi
        fi
    fi

    #
    # Main input action examination
    #

    # If a jump is set up by anchor,
    # these parameter(s) will be set
    local jump_id="" jump_data=""

    if [[ "$action" = "SELECT" ]]; then
        -zui_stdlib_get_segment "${__list[selection]}" "$ZUILIST_CURRENT_SEGMENT" tmp
        # Is it a hyperlink selection? If not, then examine select_mode
        # to know if the text selection (ZUI[text_select] is examined in
        # zui-list-input) should be passed outside the list
        if -zui_stdlib_is_any_hyperlink "$tmp" || [[ "${ZUI[select_mode]}" = (restart|quit) ]]; then
            REPLY="$selection"
            reply=( "${__list[@]}" )
            break
        fi

        # ZUI[select_mode] == no-restart
        # No passing outside, will invoke callback, but need to
        # know if on whole line, or on single text-bit segment
        if [[ "${ZUI[text_mode]}" = "off" ]] || [[ "${ZUI[text_mode]}" = "hyp" ]] && ! -zui_stdlib_has_any_hyperlinks "${__list[selection]}"; then
            # Text-bit navigation is disabled - this must be whole line selection
            # ... is enabled for with-hyperlinks lines, but line is without hyperlinks - ...
            (( ${+functions[-zui-standard-text-select-callback]} )) && -zui-standard-text-select-callback "line" "${__list[selection]}"
            ZUI[line_selected]="${__list[selection]}"
        else
            (( ${+functions[-zui-standard-text-select-callback]} )) && -zui-standard-text-select-callback "segment" "$tmp"
            ZUI[pure_text_selected]="$tmp"
        fi
    elif [[ "$action" = F[1-4] ]]; then
        REPLY="$action"
        reply=( "$__list[@]" )
        break
    elif [[ "$action" = "BR_MOVE_LEFT" || "$action" = "BR_MOVE_RIGHT" ]]; then
        REPLY="$action"
        reply=( "$__list[@]" )
        break
    elif [[ "$action" = "QUIT" ]]; then
        REPLY=-1
        reply=( "${__list[@]}" )
        break
    elif [[ "$action" = "REDRAW" ]]; then
        zcurses clear "$wname_main" redraw
        # Status window is optional (2/2)
        [[ -n "$wname_status" ]] && zcurses clear "$wname_status" redraw

        # Handle resize, force terminal-size read
        -zui_list_handle_resize 1
    elif [[ "$action" = "HYPERLINK" ]]; then
        -zui_stdlib_get_segment "${__list[selection]}" "$ZUILIST_CURRENT_SEGMENT"
        -zui_stdlib_decode "$REPLY"
        local id="${reply[1]}"
        ZUI[pressed_now]="$id"
        integer call_hook=0
        if [[ "$id" = zuianchor* ]]; then
            jump_id="$id"
            jump_data="${reply[2]}"
            id="zuiiaction${id#zuianchor}"
            call_hook=1
        elif [[ "$id" = zuiiaction* ]]; then
            call_hook=1
        fi

        # Is there hook to launch?
        if [[ $call_hook -gt 0 && -n "${ZUI[$id]}" ]]; then
            reply[1]="${reply[1]#(zuiiaction|zuiaction|zuieanchor|zuianchor|zuitfield|zuilbox)}"
            # Call the handler with all hyper-link
            # data or eval code, not using the data
            if [[ "${ZUI[$id]}" = *(=|\(\(| * )* ]]; then
                eval "${ZUI[$id]}"
            else
                "${ZUI[$id]}" "${reply[@]}"
            fi
        fi
    elif [[ "$action" = TFIELD* ]]; then
        -zui_stdlib_get_segment "${__list[selection]}" "$ZUILIST_CURRENT_SEGMENT"
        -zui_stdlib_decode "$REPLY" && local id="${reply[1]}" || local id="-"
        if [[ "$action" = TFIELD_LEFT && -n "${ZUI[$id]}" ]]; then
            ZUILIST_REGENERATE_LIST="2" # regenerate only display list
            reply[1]="${reply[1]#(zuiiaction|zuiaction|zuieanchor|zuianchor|zuitfield|zuilbox)}"
            if [[ "${ZUI[$id]}" = *(=|\(\(| * )* ]]; then
                eval "${ZUI[$id]}"
            else
                "${ZUI[$id]}" "${reply[@]}"
            fi
        fi
    elif [[ "$action" = LBOX* ]]; then
        -zui_stdlib_get_segment "${__list[selection]}" "$ZUILIST_CURRENT_SEGMENT"
        -zui_stdlib_decode "$REPLY" && local id="${reply[1]}" || local id="-"
        if [[ "$action" = LBOX_LEFT && -n "${ZUI[$id]}" ]]; then
            ZUILIST_REGENERATE_LIST="2" # regenerate only display list
            reply[1]="${reply[1]#(zuiiaction|zuiaction|zuieanchor|zuianchor|zuitfield|zuilbox)}"
            if [[ "${ZUI[$id]}" = *(=|\(\(| * )* ]]; then
                eval "${ZUI[$id]}"
            else
                "${ZUI[$id]}" "${reply[@]}"
            fi
            zcurses touch "$wname_main"
        fi
    fi

    # Now check if there are any update-on-the-fly packages submitted
    local -a update
    -zui_stdlib_decode_list_update "${ZUI[fly_update]}" update
    ZUI[fly_update]=""

    if [[ "${update[3]}" -ge 1 ]]; then
        # If the two not empty, we're updating whole
        # module and want this be treated as module
        # regeneration
        local mod=${update[1]} ice=${update[2]}
        integer update_first=$update[3]
        integer update_count=$update[4]
        shift 4 update
        integer update_size=${#update}

        # Update $@ array of this function - it
        # is "zui-list", main UI function, and
        # $@ holds original input data. So it
        # can be said that here a restart of
        # zui-list is simulated
        set -- "${(@)@[1,update_first-1]}" "${update[@]}" "${(@)@[update_first+update_count,-1]}"

        # This isn't fully correct, the list might
        # be in search or uniq mode, but that is
        # still better than previous $last_element
        last_element="$#"

        ZUILIST_REGENERATE_LIST="1"

        # How many elements push down (up if negative)
        # indices that are after the modified section
        integer size_diff=$(( update_size - update_count )) mysize
        local index index2 el var_name

        if [[ -n "$mod" && -n "$ice" ]]; then
            local -a prev_nonselectables
            var_name="prev_mod${mod}_ice${ice}_nonselectables"
            prev_nonselectables=( "${(PA@)var_name}" )
            # Remove previous nonselectables, ^ is negation, ( ) is filled with "|"-joined previous elements
            ZUILIST_NONSELECTABLE_ELEMENTS=( ${(@M)ZUILIST_NONSELECTABLE_ELEMENTS:#(#b)^(${~${(j:|:)prev_nonselectables}})} )
        fi

        # Push down (up) elements that are after the growed (shrinked) section
        # NONSELECTABLES
        mysize="${#ZUILIST_NONSELECTABLE_ELEMENTS}"
        for (( index = 1; index <= mysize; index ++ )); do
            el="${ZUILIST_NONSELECTABLE_ELEMENTS[index]}"
            # No need to check if it lays inside the range
            # as ones that did have been removed above
            if [[ "$el" -gt "$(( update_first + update_count - 1 ))" ]]; then
                (( ZUILIST_NONSELECTABLE_ELEMENTS[index] += size_diff ))
            fi
        done

        if [[ -n "$mod" && -n "$ice" ]]; then
            local -a prev_hops
            var_name="prev_mod${mod}_ice${ice}_hops"
            prev_hops=( "${(PA@)var_name}" )
            ZUILIST_HOP_INDICES=( ${(@M)ZUILIST_HOP_INDICES:#(#b)^(${~${(j:|:)prev_hops}})} )
        fi

        # Push down (up) elements that are after the growed (shrinked) section
        # HOPS
        mysize="${#ZUILIST_HOP_INDICES}"
        for (( index = 1; index <= mysize; index ++ )); do
            el="${ZUILIST_HOP_INDICES[index]}"
            # No need to check if it lays inside the range
            # as ones that did have been removed above
            if [[ "$el" -gt "$(( update_first + update_count - 1 ))" ]]; then
                (( ZUILIST_HOP_INDICES[index] += size_diff ))
            fi
        done

        # Push down (up) *_global_index parameters
        for (( index = 1; index <= 1000; ++ index )); do
            for (( index2 = 1; index2 <= 1000; ++ index2 )); do
                var_name="mod${index}_ice${index2}_global_index"
                [[ "${(P)+var_name}" = "0" ]] && break

                el="${(P)var_name}"
                if [[ -n "$el" && "$el" -gt $(( update_first + update_count - 1 )) ]]; then
                    : ${(P)var_name::=$(( el + size_diff ))}
                fi
            done

            # No first section of current module?
            (( el == 1 )) && break
        done

        # Now add new hops and nonselectables
        # first translating to global indices
        local -a nonselectables hops
        -zui_stdlib_decode_nonselectables "${ZUI[fly_nonselectables]}" nonselectables
        -zui_stdlib_decode_hops "${ZUI[fly_hops]}" hops
        ZUI[fly_nonselectables]=""
        ZUI[fly_hops]=""

        nonselectables=( "${nonselectables[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + update_first - 1 ))}" )
        hops=( "${hops[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + update_first - 1 ))}" )

        ZUILIST_NONSELECTABLE_ELEMENTS+=( "${nonselectables[@]}" )
        ZUILIST_HOP_INDICES+=( "${hops[@]}" )

        if [[ -n "$mod" && -n "$ice" ]]; then
            # Treat as module update - fill prev_*
            # parameters and also *_global_index
            var_name="prev_mod${mod}_ice${ice}_nonselectables"
            : "${(PA)var_name::=${nonselectables[@]}}";
            var_name="prev_mod${mod}_ice${ice}_hops"
            : "${(PA)var_name::=${hops[@]}}";
            var_name="prev_mod${mod}_ice${ice}_size"
            : "${(P)var_name::=$update_size}";
            var_name="mod${mod}_ice${ice}_global_index"
            : "${(P)var_name::=$update_first}";
        fi

        # Update existing anchors: global ones get
        # pushed down (up), local ones (not yet
        # processed, new) are only globalized
        local -a lanchors
        -zui_stdlib_decode_lanchors "${ZUI[fly_lanchors]}" lanchors
        for el in ${ZUI[(I)zuianchor*]} ${ZUI[(I)zuieanchor*]}; do
            if [[ "${lanchors[(r)${el#zuianchor}]}" = ${el#zuianchor} ]]; then
                ZUI[$el]=$(( ${ZUI[$el]%[-+]*} + update_first - 1 ))"${ZUI[$el]##[0-9]##}"
            elif [[ "${lanchors[(r)${el#zuieanchor}]}" = ${el#zuieanchor} ]]; then
                ZUI[$el]=$(( ${ZUI[$el]%[-+]*} + update_first - 1 ))"${ZUI[$el]##[0-9]##}"
            else
                # The $el anchor is after the replaced block?
                # In this detection only "a" in "a+b" matters
                if [[ "${ZUI[$el]%[-+]*}" -gt $(( update_first + update_count - 1 )) ]]; then
                    ZUI[$el]=$(( ${ZUI[$el]%[-+]*} + size_diff ))"${ZUI[$el]##[0-9]##}"
                fi
            fi
        done

        # On-the-fly module regeneration, not only
        # list update - this means lanchors have
        # been submitted to module${idx}_lanchors
        # parameter. They are now fully processed.
        if [[ -n "$mod" && -n "$ice" ]]; then
            var_name="mod${mod}_ice${ice}_lanchors"
            : ${(PA)var_name::=}
        fi

        # Cleanup
        unset update update_size nonselectables
        unset update_first update_count hops
        unset index mysize el var_name mod ice
    fi

    # Anchor to jump? Can be after on-the-fly
    # regeneration submitted by hook call above
    if [[ -n "$jump_id" ]]; then
        ZUI[CURRENT_IDX]=$(( ${ZUI[$jump_id]:-$jump_data} ))
        (( ZUI[CURRENT_IDX] < 1 )) && ZUI[CURRENT_IDX]=1
        [[ -z "$ZUILIST_SEARCH_BUFFER" ]] && (( ZUI[CURRENT_IDX] > last_element )) && ZUI[CURRENT_IDX]="$last_element"
        ZUILIST_CURRENT_SEGMENT=1
        ZUILIST_SEARCH_BUFFER=""
        -zui_list_compute_first_to_show_idx_center
    fi
done

# vim: set filetype=zsh:
