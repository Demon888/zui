emulate -LR zsh
setopt extendedglob

_zui_wrapper_has_terminfo=0

zmodload zsh/curses
zmodload zsh/terminfo 2>/dev/null && _zui_wrapper_has_terminfo=1

trap "-zui_wrapper_on_exit" EXIT

integer term_height="${LINES:-$(tput lines)}"
integer term_width="${COLUMNS:-$(tput cols)}"

# Reason for this function is that on some systems
# smcup and rmcup are not knowing why left empty
-zui_wrapper_alternate_screen() {
    if [ "$_zui_wrapper_has_terminfo" = "1" ]; then
        [[ "$1" = "1" && -n "$terminfo[smcup]" ]] && return
        [[ "$1" = "0" && -n "$terminfo[rmcup]" ]] && return
    fi

    case "$TERM" in
        *rxvt*)
            [ "$1" = "1" ] && echo -n $'\x1b7\x1b[?47h'
            [ "$1" = "0" ] && echo -n $'\x1b[2J\x1b[?47l\x1b8'
            ;;
        *)
            [ "$1" = "1" ] && echo -n $'\x1b[?1049h'
            [ "$1" = "0" ] && echo -n $'\x1b[?1049l'
            # just to remember two other that work: $'\x1b7\x1b[r\x1b[?47h', $'\x1b[?47l\x1b8'
            ;;
    esac
}

# Cleanup before any exit
-zui_wrapper_on_exit() {
    -zui_wrapper_end
    -zui_wrapper_alternate_screen 0
    -zui_list_cursor_visibility "plain" 1
}

-zui_wrapper_init_windows() {
    -zui_wrapper_alternate_screen 1
    zcurses init
    zcurses delwin main 2>/dev/null
    zcurses delwin status 2>/dev/null
    zcurses addwin main $(( term_height - 3 )) "$term_width" 0 0
    zcurses addwin status "3" "$term_width" $(( term_height - 3 )) 0

    zcurses bg main "+bold" white/black
    zcurses bg status "+bold" white/black
}

-zui_wrapper_end() {
    zcurses init
    zcurses delwin main 2>/dev/null
    zcurses delwin status 2>/dev/null
    zcurses end
}

-zui_wrapper_init_windows

[ "$ZUILIST_REMEMBER_STATE" != 1 ] && ZUILIST_REMEMBER_STATE=2

[[ "${ZUI[stdlib_sourced]}" != "1" ]] && source "${ZUI_REPO_DIR}/lib/stdlib.lzui"
-zui_stdlib_get_time

zui-list "main" $(( term_height-3 )) $term_width "status" "3" "$term_width" " Welcome to ${ZUI[app_name]} $REPLY " "1" "$@"

if [[ "$REPLY" != "-1" && "$REPLY" = -(#c0,1)[0-9]## ]]; then
    answer=${reply[REPLY]}
    tmp=( "${(z)answer}" )
    [[ "$ZUILIST_CURRENT_SEGMENT" -gt "${#tmp}" ]] && ZUILIST_CURRENT_SEGMENT="${#tmp}"
    ZUILIST_WRAPPER_BIT=$tmp[ZUILIST_CURRENT_SEGMENT]
else
    ZUILIST_WRAPPER_BIT=""
fi

# vim:ft=zsh
