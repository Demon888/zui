#
# Library file (*.lcmdr)
#
# Standard functions
#

# Available colors to embed in generated text
#
# Code is written as if *_E variables could be
# different, but currently there's an obstacle
# that allows only single common *_E value.
#
# Allowed color values are \03..\07.
#
# If the problem with common *_E will be fixed,
# ZUI_COMMON_E should be empty, so that code
# detects that distinct *_E are used. That said,
# this is apparently only an engineering ambition,
# as common *_E values work fine :)
typeset -g ZUI_COMMON_E=$'\031'  # octal value, decimal 25 - EM End of medium.
typeset -g ZUI_RED=$'\07'        # Bell
typeset -g ZUI_RED_E=$ZUI_COMMON_E
typeset -g ZUI_GREEN=$'\03'      # End of text
typeset -g ZUI_GREEN_E=$ZUI_COMMON_E
typeset -g ZUI_YELLOW=$'\04'     # End of transmission
typeset -g ZUI_YELLOW_E=$ZUI_COMMON_E
typeset -g ZUI_MAGENTA=$'\05'    # Enquiry
typeset -g ZUI_MAGENTA_E=$ZUI_COMMON_E
typeset -g ZUI_CYAN=$'\06'       # Acknowledge
typeset -g ZUI_CYAN_E=$ZUI_COMMON_E

# Special code used to mark active button
typeset -g ZUI_MARK=$'\026'      # octal value, decimal 22 - Synchronous idle
typeset -g ZUI_MARK_E=$ZUI_COMMON_E

# Appends hyperlink into "reply" output array. It's the
# standard action button, shown without surrounding
# "[" and "]".
#
# $1 - action ID
# $2 - data1, e.g. timestamp
# $3 - data2, e.g. command
# $4 - data3, e.g. active path
# $5 - data4, e.g. file path, file name, URL, other data
# $6 - text
# $7 - optional handler function name, can be empty text
# $8 - optional output variable name (defualt: 'reply')
# $reply array is extended by hyperlink's text (one new element)
#
function -zui_stdlib_button() {
    local __id="${(q)1}" __data1="${(q)2}" __data2="${(q)3}" __data3="${(q)4}" __data4="${(q)5}" __text="$6" __handler="$7"
    local __var_name="${8:-reply}"

    local pfx=""
    [[ -n "$__handler" ]] && {
        [[ $__handler = *internal* ]] && pfx="zuiiaction" || pfx="zuiaction"
        ZUI[$pfx$__id]="$__handler"
    }

    local -a __output
    __output=( "${(P@)__var_name}" $'\1'"$pfx$__id"$'\1'"$__data1"$'\1'"$__data2"$'\1'"$__data3"$'\1'"$__data4"$'\2'"${__text}" )

    unset pfx __id __data1 __data2 __data3 __data4 __text __handler
    : ${(PA)__var_name::=${__output[@]}}
}

# Appends button hyperlink into "reply" output array
#
# Arguments are the same as in -zui_stdlib_button
#
function -zui_stdlib_rc_button() {
    local __id="${(q)1}" __data1="${(q)2}" __data2="${(q)3}" __data3="${(q)4}" __data4="${(q)5}" __text="$6" __handler="$7"
    local __var_name="${8:-reply}"
    local -a __output

    local pfx=""
    [[ -n "$__handler" ]] && {
        [[ $__handler = *internal* ]] && pfx="zuiiaction" || pfx="zuiaction"
        ZUI[$pfx$__id]="$__handler"
    }

    __output=( "${(P@)__var_name}" $'\1'"$pfx$__id"$'\1'"$__data1"$'\1'"$__data2"$'\1'"$__data3"$'\1'"$__data4"$'\2'"[${__text}]" )

    unset pfx __id __data1 __data2 __data3 __data4 __text __handler
    : ${(PA)__var_name::=${__output[@]}}
}

# Appends anchor hyperlink into "reply" output array
# (or to array given by name via $8).
#
# Arguments are initially the same as in -zui_stdlib_\
# button, except:
#
# - the first data argument (data1, $2) needs to be
# index of line to jump to,
#
# - you normally also want to pass module number as
#   data2 ($3) if you assign a handler that is shared
#   between modules
#
# - instead of handler you might use data3 and data4
#   ($4 & $5) as list regeneration instruction, i.e.
#   pass e.g.: ",module2," "arg", to regenerate some
#   module numbered "2" with passed user-data "arg".
#
# If handler is external (i.e. doesn't have "internal"
# in its name), then it might also instruct list
# regeneration, by doing reply=( ",module2," "arg"),
# for example.
#
# Anchor that has pattern ",*," as data3 is set to be
# external. If handler has not word "internal" in its
# name then anchor is also set to be external.
#
# Example call:
#    -zui_stdlib_anchor "regen1" "4" "" ",module${1}," "$RANDOM", "[${ZUI_MAGENTA}Regen${ZUI_MAGENTA_E}]"
#
# This is done in generator, which has module number
# in $1. So, this instructs to regenerate that module,
# with no handler call, with $RANDOM as $REGENERATE_ARG
# - regeneration user-data for use by the regeneration
# code. "4" is the line number on which cursor will be
# placed.
#
function -zui_stdlib_anchor() {
    setopt localoptions extendedglob

    local __id="${(q)1}" __data1="${(q)2}" __data2="${(q)3}" __data3="${(q)4}" __data4="${(q)5}" __text="$6" __handler="$7"
    local __var_name="${8:-reply}"

    # Set to some weird line that probably exists,
    # to signal that anchor works, but input line
    # number is incorrect
    [[ "$__data1" != <-> && "$__data1" != <->[-+]<-> ]] && __data1="1+0+0+0"

    # With no handler do only no-restart jumps
    local hpfx="zuiiaction" __pfx="zuianchor"
    [[ -n "$__handler" ]] && {
        [[ $__handler = *internal* ]] || { hpfx="zuiaction"; __pfx="zuieanchor"; }
        ZUI[$hpfx$__id]="$__handler"
        unset hpfx
    } || {
        # Passed a regeneration instruction?
        # This will make link external, i.e.
        # leading to list restart (so, it's
        # "external" to the list; "internal"
        # is ran within single list run).
        [[ "$__data3" = ,*, ]] && __pfx="zuieanchor"
    }

    # Store return data
    local -a __output
    __output=( "${(P@)__var_name}" $'\1'"$__pfx$__id"$'\1'"$__data1"$'\1'"$__data2"$'\1'"$__data3"$'\1'"$__data4"$'\2'"${__text}" )
    : ${(PA)__var_name::=${__output[@]}}

    # Store anchor's target line index
    ZUI[$__pfx$__id]="$__data1"
}

# Resolves absolute path from current working directory and file path
#
# $1 - current working directory
#
# $2 - file path
#
# $reply[1] - dirname
#
# $reply[2] - basename
#
function -zui_stdlib_resolve_path() {
    local dirpath="$1" filepath="$2"

    local dirpath2="${dirpath/#\~/$HOME}"
    # :a behaves weird, prepends paths, which are not CWD
    [ "${dirpath2[1]}" = "/" ] && dirpath2="${dirpath2:a}"
    local filepath2="${filepath/#\~/$HOME}"
    [ "${filepath2[1]}" = "/" ] && filepath2="${filepath2:a}"

    reply=()
    if [ "${filepath2[1]}" = "/" ]; then
        reply[1]="${filepath2:h}"
        reply[2]="${filepath2:t}"
    else
        local p="$dirpath2/$filepath2"
        [ "${p[1]}" = "/" ] && p="${p:a}"
        reply[1]="${p:h}"
        reply[2]="${p:t}"
    fi
}

# Puts given text on command line – regardless if Zle is active or not
#
# $1 - text to put on command line
#
function -zui_stdlib_to_cmd_line() {
    if zle; then
        zle .kill-buffer
        BUFFER="$1"
        zle .redisplay
        zle .beginning-of-line
    else
        print -zr "$1"
    fi
}

#
# Returns time %H:%M, via datetime or `date` as fallback
#
function -zui_stdlib_get_time() {
    local ts
    ts="${EPOCHSECONDS}"
    [[ -z "$ts" || "$ts" = "0" ]] && REPLY="$(date '+%H:%M')" || strftime -s REPLY '%H:%M' "$ts"
}

# Returns date and time
#
# $REPLY - date and time string "Y_m_d_H.M.S"
#
function -zui_stdlib_get_datetime() {
    local ts
    ts="${EPOCHSECONDS}"
    [[ -z "$ts" || "$ts" = "0" ]] && REPLY="$(date '+%Y%m%d_%H.%M.%S')" || strftime -s REPLY '%Y%m%d_%H.%M.%S' "$ts"
}

#
# Returns timestamp, via datetime or `date` as fallback
#
function -zui_stdlib_get_timestamp() {
    REPLY="$EPOCHSECONDS"
    [[ -z "$REPLY" ]] && REPLY="$(date +%s)"
}

# Checks if given text is a hyperlink
function -zui_stdlib_is_hyperlink() {
    [[ "$1" = (#b)*$'\1'([^$'\1']#)$'\1'([^$'\1']#)$'\1'([^$'\1']#)$'\1'([^$'\1']#)$'\1'([^$'\2']#)$'\2'* ]]
}

# Decodes given hyperlink and returns data contained. Testable
# - test to check if hyperlink was correctly decoded
#
# $1 - hyperlink string
# $2 - optional output array name (default: "reply")
#
# $reply[1] - ID (of action)
# $reply[2] - time stamp
# $reply[3] - command
# $reply[4] - active path
# $reply[5] - file
#
function -zui_stdlib_decode_hyperlink() {
    if [[ "$1" = (#b)*$'\1'([^$'\1']#)$'\1'([^$'\1']#)$'\1'([^$'\1']#)$'\1'([^$'\1']#)$'\1'([^$'\2']#)$'\2'* ]]; then
        local __id="${match[1]}" __data1="${match[2]}" __data2="${match[3]}" __data3="${match[4]}" __data4="${match[5]}"
        local __var_name="${2:-reply}"
        : ${(PA)__var_name::=}
        local assgn_str="${__var_name}[1]"
        : ${(P)assgn_str::=${(Q)__id}}
        assgn_str="${__var_name}[2]"
        : ${(P)assgn_str::=${(Q)__data1}}
        assgn_str="${__var_name}[3]"
        : ${(P)assgn_str::=${(Q)__data2}}
        assgn_str="${__var_name}[4]"
        : ${(P)assgn_str::=${(Q)__data3}}
        assgn_str="${__var_name}[5]"
        : ${(P)assgn_str::=${(Q)__data4}}
        return 0
    fi

    return 1
}

# Puts given links in a box, i.e. into sequence of lines
# that are limited in length. The sequence is returned
# in reply array. The length of a link is the length of
# its text, i.e. it doesn't include meta-data.
#
# $1 - box width (line length)
# $2 - max box height (i.e. max # of lines)
# $3 - hyperlink 1
# $4 - hyperlink 2
# $5 - ...
#
function -zui_stdlib_pack_hyperlinks_into_box() {
    local width="$1" max_height="$2"
    shift 2

    reply=()
    local hyp_link __text new_line="" tmp pad
    integer idx max_idx="${#}" text_len diff_len now_width=0 now_height=0
    for (( idx=1; idx <= max_idx; idx ++ )); do
        # The box is limited in height
        (( now_height >= max_height )) && break

        hyp_link="${@[idx]}"
        __text="${hyp_link#$'\1'*$'\2'}"
        text_len="${#__text}"

        # Will hyp_link fit into this line?
        if [ "$now_width" != "0" ]; then
            if (( now_width + text_len + 1 <= width )); then
                now_width+=text_len+1
                new_line+=" $hyp_link"
            else
                # The line will be too long, pad it and store
                # it into the box array without current link
                # – leave the link for next loop run
                pad=""
                (( width-now_width > 0 )) && pad="${(r:width-now_width:: :)pad}"
                # Store the line into the box array
                reply+=( "${new_line}${pad}" )
                now_height+=1
                # Next line – empty
                new_line=""
                now_width=0
                # Repeat processing of current hyp_link
                idx=idx-1
            fi
        else
            if (( text_len <= width )); then
                now_width+=text_len
                new_line+="$hyp_link"
            else
                # Special case: a hyper-link that does
                # not fit even when it's alone in line
                diff_len=$(( ${#__text} - (width-2) ))
                hyp_link="${hyp_link[1,-diff_len-1]}"
                # Store the truncated button into box array
                reply+=( "${hyp_link}.." )
                now_height+=1
                # Next line – empty
                new_line=""
                now_width=0
            fi
        fi
    done

    # Line that wasn't filled and store wasn't triggered
    if [[ -n "$new_line" && "$now_height" -lt "$max_height" ]]; then
        pad=""
        (( width-now_width > 0 )) && pad="${(r:width-now_width:: :)pad}"
        # Store the line into the box array
        reply+=( "${new_line}${pad}" )
    fi

    #local tmp
    #for tmp in "${reply[@]}"; do
    #    echo "| $tmp |" >> /tmp/reply
    #done
}

# Return n-th (z) segment of given text
# $1 - text
# $2 - segment (default is 1)
# $3 - destination variable name (default is "REPLY")
#
# Can use e.g. 'reply[1]' for $3
function -zui_stdlib_get_segment() {
    local -a segs
    segs=( "${(z@)1}" )
    local varname="${3:-REPLY}"
    local index="${2:-1}"
    : ${(P)varname::=${segs[index]}}
}

# Returns next file to write to in circular buffer set
# of file names <base>.1 <base>.2 ... <base>.<size>
#
# The buffer is ordered according to modification time.
#
# $1 - base of file names in circular buffer
# $2 - maximum number of files in circular buffer
#
function -zui_stdlib_circular_next() {
    setopt localoptions extendedglob

    # Input data
    local base="$1" count="$2"

    # Circular buffers' directory
    local circpath="$ZUI_CONFIG_DIR/var/circular_buffers"
    [[ ! -d "$circpath" ]] && command mkdir -p "$circpath"

    local -a circular_buffer
    circular_buffer=( "$circpath"/"$base".[[:digit:]]##(OmN) )

    if [[ "$count" -gt "${#circular_buffer}" ]]; then
        integer next_index=$(( ${#circular_buffer} + 1 ))
        REPLY="$circpath/${base}.${next_index}"
    else
        REPLY="${circular_buffer[1]}"
    fi

    return 0
}

#
# Returns absolute file paths of given circular buffer.
# They are ordered from most recent to least recent.
#
# No count is obtained, so all files are returned, even
# actually disabled by buffer limit.
#
# $1 - name of the circular buffer
#
function -zui_stdlib_circular_paths() {
    setopt localoptions extendedglob

    # Input data
    local base="$1"

    # Output array
    reply=( )

    # Circular buffers' directory
    local circpath="$ZUI_CONFIG_DIR/var/circular_buffers"
    [[ ! -d "$circpath" ]] && return 1

    reply=( "$circpath"/"$base".[[:digit:]]##(omN) )
}

ZUI[stdlib_sourced]="1"

# This function clears application data
# from $ZUI global hash. To be called at
# exit and at start of zui application

function -zui_stdlib_cleanup() {
    local -a keys
    # Anchors, checkboxes, actions, internal actions
    keys=( ${ZUI[(I)zuianchor*]} ${ZUI[(I)zuieanchor*]} ${ZUI[(I)zuicheckbox*]}
           ${ZUI[(I)zuiaction*]} ${ZUI[(I)zuiiaction*]} ${ZUI[(I)fly_*]}
           app app_name PROMPT_SUBST INTERACTIVE_COMMENTS GENERATION_TIME
    )

    local k
    for k in "${keys[@]}"; do
        unset "ZUI[$k]"
    done
}

# Use this to quickly load variables:
#
# - module${idx}_global_index
# - module${idx}_size
#
# into parameters given by names.
#
# Has default target parameters' names
# (REPLY & REPLY2), this might lead to
# silent errors, but I prefer that to
# error-revealing crash.. Hm..
#
# $1 - module index
# $2 - output parameter name for global index
# $3 - output parameter name for size
function -zui_stdlib_load_global_index_and_size() {
    local tmp var_name
    2=${2:-REPLY}
    3=${3:-REPLY2}

    # Global index
    var_name="module${module}_global_index"
    tmp="${(P)var_name}"
    : ${(P)2::=$tmp}

    # Size
    var_name="module${module}_size"
    tmp="${(P)var_name}"
    : ${(P)3::=$tmp}
}

# Resets parameters reply{,2..5}
function -zui_stdlib_reset_replies() {
    local var_name="reply"
    : ${(PA)var_name::=}
    var_name="reply2"
    : ${(P)var_name::=0}
    var_name="reply3"
    : ${(PA)var_name::=}
    var_name="reply4"
    : ${(PA)var_name::=}
    var_name="reply5"
    : ${(PA)var_name::=}
}

# Internal action can call this function in
# order to replace part of list with new text.
# It uses parameters reply{,2..5} normally
# returned from a module generator. It covers
# calls to multiple submit functions:
#
# - -zui_stdlib_submit_list_update
# - -zui_stdlib_submit_nonselectables
# - -zui_stdlib_submit_hops
# - -zui_stdlib_submit_lanchors
#
# What needs to be provided is current module
# global index, i.e. its first line number in
# the whole page text. It's normaly kept in
# module${idx}_global_index.
#
# Also, current module size, i.e. the number of
# lines of text of the module, returned in `reply`
# array in previous module generation, normally
# helpd in module${idx}_size.
#
# $1 - current module global index
# $2 - current module size
function -zui_stdlib_submit_fly_from_replies() {
    local module="$1" global_index previous_size

    # Get global index and previous size. We reach for
    # prev_${m}_size parameter because here we submit
    # what means outside code that ran generator also
    # probably mapped new replies to non-prev parameters
    var_name="module${module}_global_index"
    global_index="${(P)var_name}"
    var_name="prev_module${module}_size"
    previous_size="${(P)var_name}"

    -zui_stdlib_submit_list_update "$module" "$global_index" "$(( global_index + previous_size - 1 ))" "${reply[@]}"
    -zui_stdlib_submit_nonselectables "${reply3[@]}"
    -zui_stdlib_submit_hops "${reply4[@]}"
    -zui_stdlib_submit_lanchors "${reply5[@]}"
}

# Internal action can call this function in
# order to replace part of list with new text.
#
# $1 - module index, can be empty for stray list update
# $2 - beginning line number of area to replace
# $3 - end line number of area to replace
# $4, $5, ... - new elements to replace lines $1..$2
function -zui_stdlib_submit_list_update() {
    integer size=$(( $3 - $2 + 1 ))
    3=$size
    ZUI[fly_update]="${(j: :)${(q)@}}"
}

# Internal action can call this function when
# replacing part of list to provide new hops,
# by submitting local indices. They will be
# automatically translated to global indices.
#
# $1, $2, ... - local indices of hops in the
#               substituted fragment
function -zui_stdlib_submit_hops() {
    ZUI[fly_hops]="${(j: :)${(q)@}}"
}

# Internal action can call this function when
# replacing part of list to provide new local
# indices that are non-selectable. They will
# be translated to global indices.
#
# $1, $2, ... - local indices of nonselectables
#               in the substituted fragment
function -zui_stdlib_submit_nonselectables() {
    ZUI[fly_nonselectables]="${(j: :)${(q)@}}"
}

# Internal action can call this function when
# replacing part of list to provide new local
# anchors (their IDs). Their indices (stored
# in $ZUI) will be globalized.
#
# $1, $2, ... - IDs of anchors to be globalized
function -zui_stdlib_submit_lanchors() {
    ZUI[fly_lanchors]="${(j: :)${(q)@}}"
}

# Deserializes on-the-fly update package.
# To be used rather only internally.
#
# $1 - the package
# $2 - optional target parameter name
function -zui_stdlib_decode_list_update() {
    local -a __segments
    [[ -n "$1" ]] && __segments=( "${(z@)1}" ) || __segments=( "" 0 0 )
    local __var_name="${2-reply}"

    : ${(PA)__var_name::="${(Q)__segments[@]}"}
}

# Deserializes on-the-fly hops substitution.
# For internal usage.
#
# $1 - the hops' package
# $2 - optional target parameter name
function -zui_stdlib_decode_hops() {
    local -a __hops
    [[ -n "$1" ]] && __hops=( "${(z@)1}" ) || __hops=( )
    local __var_name="${2-reply}"
    : ${(PA)__var_name::=${(Q)__hops[@]}}
}

# Deserializes on-the-fly nonselectables
# substitution. For internal usage.
#
# $1 - the nonselectables' package
# $2 - optional target parameter name
function -zui_stdlib_decode_nonselectables() {
    local -a __nonselectables
    [[ -n "$1" ]] && __nonselectables=( "${(z@)1}" ) || __nonselectables=( )
    local __var_name="${2-reply}"
    : ${(PA)__var_name::="${(Q)__nonselectables[@]}"}
}

# Deserializes on-the-fly local anchors.
# For internal usage.
#
# $1 - the anchors' package
# $2 - optional target parameter name
function -zui_stdlib_decode_lanchors() {
    local -a __lanchors
    [[ -n "$1" ]] && __lanchors=( "${(z@)1}" ) || __lanchors=( )
    local __var_name="${2-reply}"
    : ${(PA)__var_name::="${(Q)__lanchors[@]}"}
}

# Maps reply{,2..5} parameters onto module
# parameters:
#    module${idx}_output module${idx}_nonselectables
#    module${idx}_hops module${idx}_lanchors
#    module${idx}_size
#
# $1 - module index
function -zui_stdlib_map_replies() {
    var_name="module${1}_output"
    : ${(PA)var_name::="${reply[@]}"}
    var_name="module${1}_size"
    : ${(PA)var_name::=$reply2}
    var_name="module${1}_nonselectables"
    : ${(PA)var_name::="${reply3[@]}"}
    var_name="module${1}_hops"
    : ${(PA)var_name::="${reply4[@]}"}
    var_name="module${1}_lanchors"
    : ${(PA)var_name::="${reply5[@]}"}
}

# Appends module_${1}_lanchors into array
# given by name
#
# $1 - module index
# $2 - target array name
function -zui_stdlib_gather_lanchors() {
    local __var_name1="module_${1}_lanchors" __var_name2="$2"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "-zui_stdlib_gather_lanchors must obtain module index and target array name"
        return 1
    fi

    # Append and store
    local -a __output
    __output=( "${(P@)__var_name2}" "${(P@)__var_name1}" )
    : ${(PA)__var_name2::=${__output[@]}}
}
# vim:ft=zsh
