#
# Started from zle or from command line
#

[[ "${ZUI[stdlib_sourced]}" != "1" ]] && source "${ZUI_REPO_DIR}/stdlib.lzui"

# Cleanup $ZUI hash runtime data
-zui_stdlib_cleanup

[[ -o interactivecomments ]] && ZUI[INTERACTIVE_COMMENTS]="1" || ZUI[INTERACTIVE_COMMENTS]="0"
[[ -o promptsubst ]] && ZUI[PROMPT_SUBST]="1" || ZUI[PROMPT_SUBST]="0"

emulate -LR zsh
setopt extendedglob typesetsilent warncreateglobal

[[ "${ZUI[PROMPT_SUBST]}" = "1" ]] && setopt promptsubst

ZUI[app]="zui-test"

##
## Main code
##

# Measure and limit generation time
typeset -F SECONDS=0.0
local -F start_seconds

#
# Actions
#

-zui_external_test_action_1() {
    local -a zip_B
    zip_B=( "$@" )
    local -a zip_A
    zip_A=( "ID:" "Data 1:" "Data 2:" "Data 3:" "Data 4:" )

    print "Hello world!"

    local v1 v2
    for v1 v2 in "${(@)zip_A:^zip_B}"; do
        print "$v1 $v2"
    done
}

-zui_external_anchor_action_2() {
    print "I've jumped even though list has been restarted!"
}

#
# Internal actions
#

-zui_test_internal_action_1() {
    zcurses bg "status" "white/blue"
}

#
# Other callbacks
#

# Optional, unset explicitly if unused
# It generates additional status text, displayed after
# "Current #...", from data of highlighted button
-zui-standard-status-callback() {
    local id data1 data2 data3 data4 text handler
    id="$1"
    data3="$3"
    handler="$7"

    reply=( "My id: $id" " My data: $data3" " My handler:" " $handler" )
}

#
# Generators for module
#

# Generator for module 1
-zui_test_module1_generator() {
    reply=( )
    -zui_stdlib_rc_button "there" "" "/Jump/" "" "" "${ZUI_MAGENTA}there${ZUI_MAGENTA_E}" -zui_external_test_action_1
    reply=( "Hello World" "Hello ${reply[1]}" "Third line" )
    reply2=3
    reply3=( 1 )
    reply4=( 1 3 )
}

# Generator for module 2
-zui_test_module2_generator() {
    reply=( "Second Module" "I'm not selectable" "Last line" )
    reply2=3
    reply3=( 2 )
    reply4=( 1 3 )
}

#
# Business logic follows
#

local curcontext=":zle:$WIDGET"
local MATCH; local -i MBEGIN MEND
local -a match mbegin mend

#
# General zstyles
#

#
# Variables
#

local -A ZUI_SECTION_INDICES

# Replies from generation modules
local -a reply reply3 reply4
integer reply2

# Module 1
local -a module1_output module1_nonselectables module1_hops
local -a prev_module1_nonselectables prev_module1_hops
integer module1_size prev_module1_size

# Module 2
local -a module2_output module2_nonselectables module2_hops
local -a prev_module2_nonselectables prev_module2_hops
integer module2_size prev_module2_size

###
### REGENERATION REQUEST LOOP ###
###

local REGENERATE="" REGENERATE_ARG="" REGENERATE_ALWAYS=""

while (( 1 )); do

# Measure generation time
start_seconds=$SECONDS

#
# Common regeneration block
#

if [[ -z "$REGENERATE" || "$REGENERATE" = *,all,* ]]
then

fi

#
# Module 1
#

if [[ -z "$REGENERATE" || "$REGENERATE" = *,module1,* || "$REGENERATE" = *,all,* ]]; then
    reply=( ); reply2="0"; reply3=( ); reply4=( )

    -zui_test_module1_generator

    module1_output=( "${reply[@]}" )
    module1_size=$reply2
    module1_nonselectables=( "${reply3[@]}" )
    module1_hops=( "${reply4[@]}" )
fi

#
# Module 2
#

if [[ -z "$REGENERATE" || "$REGENERATE" = *,module2,* || "$REGENERATE" = *,all,* ]]; then
    reply=( ); reply2="0"; reply3=( ); reply4=( )

    -zui_test_module2_generator

    module2_output=( "${reply[@]}" )
    module2_size=$reply2
    module2_nonselectables=( "${reply3[@]}" )
    module2_hops=( "${reply4[@]}" )
fi

#
# Store all results into OUTPUT, ZUILIST_NONSELECTABLE_ELEMENTS, ZUILIST_HOP_INDICES
#

typeset -ga ZUILIST_NONSELECTABLE_ELEMENTS ZUILIST_HOP_INDICES
ZUILIST_NONSELECTABLE_ELEMENTS=()
ZUILIST_HOP_INDICES=()

local -a OUTPUT output nonselectables hops
local -a prev_nonselectables prev_hops
local -a anchors
local n var_name
integer LINE_COUNT size

OUTPUT=( )
LINE_COUNT=0
anchors=( )

for n in "module1" "module2"; do
    # Get output
    var_name="${n}_output"
    output=( "${(PA@)var_name}" )

    # Get output size
    var_name="${n}_size"
    size="${(P)var_name}"

    # Get nonselectables
    var_name="${n}_nonselectables"
    nonselectables=( "${(PA@)var_name}" )

    # Get hops
    var_name="${n}_hops"
    hops=( "${(PA@)var_name}" )

    # Get previous nonselectables
    var_name="prev_${n}_nonselectables"
    prev_nonselectables=( "${(PA@)var_name}" )

    # Get previous hops
    var_name="prev_${n}_hops"
    prev_hops=( "${(PA@)var_name}" )

    if (( size > 0 )); then
        OUTPUT+=( "" )
        LINE_COUNT+=1
        # + 1 for the anchors at top
        ZUILIST_NONSELECTABLE_ELEMENTS+=( "$(( LINE_COUNT + 1 ))" )
    fi

    # Translate returned indices to global ones
    # The + 1 is for anchors at the top
    nonselectables=( "${nonselectables[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + LINE_COUNT + 1 ))}" )
    hops=( "${hops[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + LINE_COUNT + 1 ))}" )

    # Add translated, current hops and nonselectables
    ZUILIST_NONSELECTABLE_ELEMENTS+=( "${nonselectables[@]}" )
    ZUILIST_HOP_INDICES+=( "${hops[@]}" )

    # Alter current index if size of section was changed
    # - using *_size, prev_*_size parameters
    if [[ "$n" = "module1" && "$REGENERATE" = *,module1,* ]]; then
        integer delta=$(( log_size-prev_log_size ))
        ZUILIST_CURRENT_IDX=$(( ZUILIST_CURRENT_IDX + delta ))
    elif [[ "$n" = "module2" && "$REGENERATE" = *,module2,* ]]; then
        ZUILIST_CURRENT_IDX="4"
        ZUILIST_CURRENT_SEGMENT="1"
    fi

    # Also store the indices into prev_* arrays
    var_name="prev_${n}_nonselectables"
    : "${(PA)var_name::=${nonselectables[@]}}";
    var_name="prev_${n}_hops"
    : "${(PA)var_name::=${hops[@]}}";
    var_name="prev_${n}_size"
    : "${(P)var_name::=${size}}";

    # Create anchors for selected sections
    reply=( )
    if [[ "$n" = "module1" ]]; then
        [[ -n "${hops[1]}" ]] && -zui_stdlib_anchor "1" "${hops[1]}" "/Jump/" "" "$size" "[${ZUI_MAGENTA}Module1${ZUI_MAGENTA_E}]" -zui_external_anchor_action_2
    elif [[ "$n" = "module2" ]]; then
        [[ -n "${hops[1]}" ]] && -zui_stdlib_anchor "2" "${hops[1]}" "/Jump & Load/" "" "$size" "[${ZUI_CYAN}Module2${ZUI_CYAN_E}]" -zui_test_internal_action_1
    fi
    anchors+=( "${reply[@]}" )

    ZUI_SECTION_INDICES[$n]=$(( LINE_COUNT + 1 ))
    OUTPUT+=( "${output[@]}" )
    LINE_COUNT+=size
done

# Reset regeneration variables and prev_current_project
REGENERATE=""
REGENERATE_ARG=""

#
# Generation time
#

local generation_time="$(( SECONDS - start_seconds ))"
ZUI[GENERATION_TIME]="${generation_time[1,4]}"

#
# Invoke the list, handle outcome
#

ZUILIST_HOP_INDICES+=( 1 ) # jump to anchors
local ZUILIST_WRAPPER_BIT=""
zui-usetty-wrapper zui-list-wrapper "${anchors[*]}" "${OUTPUT[@]}"

if [ -z "$ZUILIST_WRAPPER_BIT" ]; then
    zle && { zle .redisplay; zle .reset-prompt; }

    # Cleanup $ZUI hash runtime data
    -zui_stdlib_cleanup

    return 1
fi

# ID, data1, data2, data3, data4
if -zui_stdlib_decode_hyperlink "$ZUILIST_WRAPPER_BIT"; then
    local id="${reply[1]}" data1="${reply[2]}" data2="${reply[3]}" data3="${reply[4]}" data4="${reply[5]}"

    REGENERATE="$data2"
    REGENERATE_ARG="$data3"
    REGENERATE+="$REGENERATE_ALWAYS"

    integer call_hook=0
    if [[ "$id" = zuieanchor* ]]; then
        ZUILIST_CURRENT_IDX="${ZUI[$id]-$data1}"
        ZUILIST_CURRENT_SEGMENT=1
        id="zuiaction${id#zuieanchor}"
        call_hook=1
    elif [[ "$id" = zuiaction* ]]; then
        call_hook=1
    fi

    if [[ $call_hook -gt 0 && -n "${ZUI[$id]}" ]]; then
        reply[1]="${${${${${reply[1]#zuiiaction}#zuiaction}#zuicheckbox}#zuieanchor}#zuianchor}"
        # Call the handler with all hyper-link data
        "${ZUI[$id]}" "${reply[@]}"
    fi
fi

### REGENERATION REQUEST LOOP ###
done

# Cleanup $ZUI hash runtime data
-zui_stdlib_cleanup

return 0

# vim:ft=zsh
